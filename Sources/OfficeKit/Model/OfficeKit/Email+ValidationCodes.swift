/*
 * !!! File autogenerated by convert_email_xml_inputs_to_swift.swift
 * !!! Don’t change manually.
 *
 * Email+ValidationCodes.swift
 * OfficeKit
 *
 * Created by convert_email_xml_inputs_to_swift.swift on 3/27/19.
 */

import Foundation



extension Email {
	
	public struct ValidationCategory : Hashable {
		
		public static let validCategory = ValidationCategory(value: 1, xmlId: String(data: Data(#"ISEMAIL_VALID_CATEGORY"#.utf8), encoding: .nonLossyASCII)!, description: String(data: Data(#"Address is valid"#.utf8), encoding: .nonLossyASCII)!)
		public static let dnswarn = ValidationCategory(value: 7, xmlId: String(data: Data(#"ISEMAIL_DNSWARN"#.utf8), encoding: .nonLossyASCII)!, description: String(data: Data(#"Address is valid but a DNS check was not successful"#.utf8), encoding: .nonLossyASCII)!)
		public static let rfc5321 = ValidationCategory(value: 15, xmlId: String(data: Data(#"ISEMAIL_RFC5321"#.utf8), encoding: .nonLossyASCII)!, description: String(data: Data(#"Address is valid for SMTP but has unusual elements"#.utf8), encoding: .nonLossyASCII)!)
		public static let cfws = ValidationCategory(value: 31, xmlId: String(data: Data(#"ISEMAIL_CFWS"#.utf8), encoding: .nonLossyASCII)!, description: String(data: Data(#"Address is valid within the message but cannot be used unmodified for the envelope"#.utf8), encoding: .nonLossyASCII)!)
		public static let deprec = ValidationCategory(value: 63, xmlId: String(data: Data(#"ISEMAIL_DEPREC"#.utf8), encoding: .nonLossyASCII)!, description: String(data: Data(#"Address contains deprecated elements but may still be valid in restricted contexts"#.utf8), encoding: .nonLossyASCII)!)
		public static let rfc5322 = ValidationCategory(value: 127, xmlId: String(data: Data(#"ISEMAIL_RFC5322"#.utf8), encoding: .nonLossyASCII)!, description: String(data: Data(#"The address is only valid according to the broad definition of RFC 5322. It is otherwise invalid."#.utf8), encoding: .nonLossyASCII)!)
		public static let err = ValidationCategory(value: 255, xmlId: String(data: Data(#"ISEMAIL_ERR"#.utf8), encoding: .nonLossyASCII)!, description: String(data: Data(#"Address is invalid for any purpose"#.utf8), encoding: .nonLossyASCII)!)
		
		public let value: Int
		public let xmlId: String
		public let description: String

		private init(value v: Int, xmlId pi: String, description d: String) {
			value = v
			xmlId = pi
			description = d
		}
		
	}
	
}


extension Email {
	
	public struct ValidationSMTPInfo : Hashable {
		
		public static let code250215 = ValidationSMTPInfo(value: String(data: Data(#"2.1.5"#.utf8), encoding: .nonLossyASCII)!, xmlId: String(data: Data(#"ISEMAIL_META_SMTP_250_215"#.utf8), encoding: .nonLossyASCII)!, text: String(data: Data(#"250 2.1.5 ok"#.utf8), encoding: .nonLossyASCII)!)
		public static let code553510 = ValidationSMTPInfo(value: String(data: Data(#"5.1.0"#.utf8), encoding: .nonLossyASCII)!, xmlId: String(data: Data(#"ISEMAIL_META_SMTP_553_510"#.utf8), encoding: .nonLossyASCII)!, text: String(data: Data(#"553 5.1.0 Other address status"#.utf8), encoding: .nonLossyASCII)!)
		public static let code553511 = ValidationSMTPInfo(value: String(data: Data(#"5.1.1"#.utf8), encoding: .nonLossyASCII)!, xmlId: String(data: Data(#"ISEMAIL_META_SMTP_553_511"#.utf8), encoding: .nonLossyASCII)!, text: String(data: Data(#"553 5.1.1 Bad destination mailbox address"#.utf8), encoding: .nonLossyASCII)!)
		public static let code553512 = ValidationSMTPInfo(value: String(data: Data(#"5.1.2"#.utf8), encoding: .nonLossyASCII)!, xmlId: String(data: Data(#"ISEMAIL_META_SMTP_553_512"#.utf8), encoding: .nonLossyASCII)!, text: String(data: Data(#"553 5.1.2 Bad destination system address"#.utf8), encoding: .nonLossyASCII)!)
		public static let code553513 = ValidationSMTPInfo(value: String(data: Data(#"5.1.3"#.utf8), encoding: .nonLossyASCII)!, xmlId: String(data: Data(#"ISEMAIL_META_SMTP_553_513"#.utf8), encoding: .nonLossyASCII)!, text: String(data: Data(#"553 5.1.3 Bad destination mailbox address syntax"#.utf8), encoding: .nonLossyASCII)!)
		
		public let value: String
		public let xmlId: String
		public let text: String

		private init(value v: String, xmlId pi: String, text t: String) {
			value = v
			xmlId = pi
			text = t
		}
		
	}
	
}


extension Email {
	
	public struct ValidationReference : Hashable {
		
		public static let localPart = ValidationReference(xmlId: String(data: Data(#"local-part"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5322 section 3.4.1"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5322\043section-3.4.1"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   local-part      =   dot-atom / quoted-string / obs-local-part\012\012   dot-atom        =   [CFWS] dot-atom-text [CFWS]\012\012   dot-atom-text   =   1*atext *(\042.\042 1*atext)\012\012   quoted-string   =   [CFWS]\012                       DQUOTE *([FWS] qcontent) [FWS] DQUOTE\012                       [CFWS]\012\012   obs-local-part  =   word *(\042.\042 word)\012\012   word            =   atom / quoted-string\012\012   atom            =   [CFWS] 1*atext [CFWS]"#.utf8), encoding: .nonLossyASCII)!)
		public static let localPartMaximum = ValidationReference(xmlId: String(data: Data(#"local-part-maximum"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5322 section 4.5.3.1.1"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5321\043section-4.5.3.1.1"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   The maximum total length of a user name or other local-part is 64\012   octets."#.utf8), encoding: .nonLossyASCII)!)
		public static let obsLocalPart = ValidationReference(xmlId: String(data: Data(#"obs-local-part"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5322 section 3.4.1"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5322\043section-3.4.1"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   obs-local-part  =   word *(\042.\042 word)\012\012   word            =   atom / quoted-string\012\012   atom            =   [CFWS] 1*atext [CFWS]\012\012   quoted-string   =   [CFWS]\012                       DQUOTE *([FWS] qcontent) [FWS] DQUOTE\012                       [CFWS]\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let dotAtom = ValidationReference(xmlId: String(data: Data(#"dot-atom"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5322 section 3.4.1"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5322\043section-3.4.1"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   dot-atom        =   [CFWS] dot-atom-text [CFWS]\012\012   dot-atom-text   =   1*atext *(\042.\042 1*atext)\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let quotedString = ValidationReference(xmlId: String(data: Data(#"quoted-string"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5322 section 3.4.1"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5322\043section-3.4.1"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   quoted-string   =   [CFWS]\012                       DQUOTE *([FWS] qcontent) [FWS] DQUOTE\012                       [CFWS]\012\012   qcontent        =   qtext / quoted-pair\012\012   qtext           =   %d33 /             ; Printable US-ASCII\012                       %d35-91 /          ;  characters not including\012                       %d93-126 /         ;  \042\\\042 or the quote character\012                       obs-qtext\012\012   quoted-pair     =   (\042\\\042 (VCHAR / WSP)) / obs-qp\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let cfwsNearAt = ValidationReference(xmlId: String(data: Data(#"CFWS-near-at"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5322 section 3.4.1"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5322\043section-3.4.1"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   Comments and folding white space\012   SHOULD NOT be used around the \042@\042 in the addr-spec.\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let shouldNot = ValidationReference(xmlId: String(data: Data(#"SHOULD-NOT"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 2119 section 4"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc2119"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012 4. SHOULD NOT   This phrase, or the phrase \042NOT RECOMMENDED\042 mean that\012    there may exist valid reasons in particular circumstances when the\012    particular behavior is acceptable or even useful, but the full\012    implications should be understood and the case carefully weighed\012    before implementing any behavior described with this label.\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let atext = ValidationReference(xmlId: String(data: Data(#"atext"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5322 section 3.2.3"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5322\043section-3.2.3"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012    atext           =   ALPHA / DIGIT /    ; Printable US-ASCII\012                        \042!\042 / \042\043\042 /        ;  characters not including\012                        \042$\042 / \042%\042 /        ;  specials.  Used for atoms.\012                        \042&\042 / \042'\042 /\012                        \042*\042 / \042+\042 /\012                        \042-\042 / \042/\042 /\012                        \042=\042 / \042?\042 /\012                        \042^\042 / \042_\042 /\012                        \042`\042 / \042{\042 /\012                        \042|\042 / \042}\042 /\012                        \042~\042\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let obsDomain = ValidationReference(xmlId: String(data: Data(#"obs-domain"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5322 section 3.4.1"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5322\043section-3.4.1"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   obs-domain      =   atom *(\042.\042 atom)\012\012   atom            =   [CFWS] 1*atext [CFWS]\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let domainRfc5322 = ValidationReference(xmlId: String(data: Data(#"domain-RFC5322"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5322 section 3.4.1"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5322\043section-3.4.1"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   domain          =   dot-atom / domain-literal / obs-domain\012\012   dot-atom        =   [CFWS] dot-atom-text [CFWS]\012\012   dot-atom-text   =   1*atext *(\042.\042 1*atext)\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let domainRfc5321 = ValidationReference(xmlId: String(data: Data(#"domain-RFC5321"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5321 section 4.1.2"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5321\043section-4.1.2"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   Domain         = sub-domain *(\042.\042 sub-domain)\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let subDomain = ValidationReference(xmlId: String(data: Data(#"sub-domain"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5321 section 4.1.2"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5321\043section-4.1.2"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   Domain         = sub-domain *(\042.\042 sub-domain)\012\012   Let-dig        = ALPHA / DIGIT\012\012   Ldh-str        = *( ALPHA / DIGIT / \042-\042 ) Let-dig\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let label = ValidationReference(xmlId: String(data: Data(#"label"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5321 section 4.1.2"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc1035\043section-2.3.4"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   labels          63 octets or less\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let crlf = ValidationReference(xmlId: String(data: Data(#"CRLF"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5234 section 2.3"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5234\043section-2.3"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   CRLF        =  %d13.10\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let cfws = ValidationReference(xmlId: String(data: Data(#"CFWS"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5322 section 3.2.2"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5322\043section-3.2.2"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   CFWS            =   (1*([FWS] comment) [FWS]) / FWS\012\012   FWS             =   ([*WSP CRLF] 1*WSP) /  obs-FWS\012                                          ; Folding white space\012\012   comment         =   \042(\042 *([FWS] ccontent) [FWS] \042)\042\012\012   ccontent        =   ctext / quoted-pair / comment\012\012   ctext           =   %d33-39 /          ; Printable US-ASCII\012                       %d42-91 /          ;  characters not including\012                       %d93-126 /         ;  \042(\042, \042)\042, or \042\\\042\012                       obs-ctext\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let domainLiteral = ValidationReference(xmlId: String(data: Data(#"domain-literal"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5322 section 3.4.1"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5322\043section-3.4.1"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   domain-literal  =   [CFWS] \042[\042 *([FWS] dtext) [FWS] \042]\042 [CFWS]\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let addressLiteral = ValidationReference(xmlId: String(data: Data(#"address-literal"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5321 section 4.1.2"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5321\043section-4.1.2"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   address-literal  = \042[\042 ( IPv4-address-literal /\012                    IPv6-address-literal /\012                    General-address-literal ) \042]\042\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let addressLiteralIpv4 = ValidationReference(xmlId: String(data: Data(#"address-literal-IPv4"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5321 section 4.1.3"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5321\043section-4.1.3"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   IPv4-address-literal  = Snum 3(\042.\042  Snum)\012\012   Snum           = 1*3DIGIT\012                  ; representing a decimal integer\012                  ; value in the range 0 through 255\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let addressLiteralIpv6 = ValidationReference(xmlId: String(data: Data(#"address-literal-IPv6"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5321 section 4.1.3"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5321\043section-4.1.3"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   IPv6-address-literal  = \042IPv6:\042 IPv6-addr\012\012   IPv6-addr      = IPv6-full / IPv6-comp / IPv6v4-full / IPv6v4-comp\012\012   IPv6-hex       = 1*4HEXDIG\012\012   IPv6-full      = IPv6-hex 7(\042:\042 IPv6-hex)\012\012   IPv6-comp      = [IPv6-hex *5(\042:\042 IPv6-hex)] \042::\042\012                  [IPv6-hex *5(\042:\042 IPv6-hex)]\012                  ; The \042::\042 represents at least 2 16-bit groups of\012                  ; zeros.  No more than 6 groups in addition to the\012                  ; \042::\042 may be present.\012\012   IPv6v4-full    = IPv6-hex 5(\042:\042 IPv6-hex) \042:\042 IPv4-address-literal\012\012   IPv6v4-comp    = [IPv6-hex *3(\042:\042 IPv6-hex)] \042::\042\012                  [IPv6-hex *3(\042:\042 IPv6-hex) \042:\042]\012                  IPv4-address-literal\012                  ; The \042::\042 represents at least 2 16-bit groups of\012                  ; zeros.  No more than 4 groups in addition to the\012                  ; \042::\042 and IPv4-address-literal may be present.\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let dtext = ValidationReference(xmlId: String(data: Data(#"dtext"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5322 section 3.4.1"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5322\043section-3.4.1"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   dtext           =   %d33-90 /          ; Printable US-ASCII\012                       %d94-126 /         ;  characters not including\012                       obs-dtext          ;  \042[\042, \042]\042, or \042\\\042\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let obsDtext = ValidationReference(xmlId: String(data: Data(#"obs-dtext"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5322 section 3.4.1"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5322\043section-3.4.1"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   obs-dtext       =   obs-NO-WS-CTL / quoted-pair\012\012   obs-NO-WS-CTL   =   %d1-8 /            ; US-ASCII control\012                       %d11 /             ;  characters that do not\012                       %d12 /             ;  include the carriage\012                       %d14-31 /          ;  return, line feed, and\012                       %d127              ;  white space characters\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let qtext = ValidationReference(xmlId: String(data: Data(#"qtext"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5322 section 3.2.4"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5322\043section-3.2.4"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   qtext           =   %d33 /             ; Printable US-ASCII\012                       %d35-91 /          ;  characters not including\012                       %d93-126 /         ;  \042\\\042 or the quote character\012                       obs-qtext\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let obsQtext = ValidationReference(xmlId: String(data: Data(#"obs-qtext"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5322 section 4.1"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5322\043section-4.1"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   obs-qtext       =   obs-NO-WS-CTL\012\012   obs-NO-WS-CTL   =   %d1-8 /            ; US-ASCII control\012                       %d11 /             ;  characters that do not\012                       %d12 /             ;  include the carriage\012                       %d14-31 /          ;  return, line feed, and\012                       %d127              ;  white space characters\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let ctext = ValidationReference(xmlId: String(data: Data(#"ctext"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5322 section 3.2.3"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5322\043section-3.2.3"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   ctext           =   %d33-39 /          ; Printable US-ASCII\012                       %d42-91 /          ;  characters not including\012                       %d93-126 /         ;  \042(\042, \042)\042, or \042\\\042\012                       obs-ctext\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let obsCtext = ValidationReference(xmlId: String(data: Data(#"obs-ctext"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5322 section 4.1"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5322\043section-4.1"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   obs-qtext       =   obs-NO-WS-CTL\012\012   obs-NO-WS-CTL   =   %d1-8 /            ; US-ASCII control\012                       %d11 /             ;  characters that do not\012                       %d12 /             ;  include the carriage\012                       %d14-31 /          ;  return, line feed, and\012                       %d127              ;  white space characters\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let quotedPair = ValidationReference(xmlId: String(data: Data(#"quoted-pair"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5322 section 3.2.1"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5322\043section-3.2.1"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   quoted-pair     =   (\042\\\042 (VCHAR / WSP)) / obs-qp\012\012   VCHAR           =  %d33-126            ; visible (printing) characters\012   WSP             =  SP / HTAB           ; white space\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let obsQp = ValidationReference(xmlId: String(data: Data(#"obs-qp"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5322 section 4.1"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5322\043section-4.1"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   obs-qp          =   \042\\\042 (%d0 / obs-NO-WS-CTL / LF / CR)\012\012   obs-NO-WS-CTL   =   %d1-8 /            ; US-ASCII control\012                       %d11 /             ;  characters that do not\012                       %d12 /             ;  include the carriage\012                       %d14-31 /          ;  return, line feed, and\012                       %d127              ;  white space characters\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let tld = ValidationReference(xmlId: String(data: Data(#"TLD"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5321 section 2.3.5"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5321\043section-2.3.5"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   In the case\012   of a top-level domain used by itself in an email address, a single\012   string is used without any dots.  This makes the requirement,\012   described in more detail below, that only fully-qualified domain\012   names appear in SMTP transactions on the public Internet,\012   particularly important where top-level domains are involved.\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let tldFormat = ValidationReference(xmlId: String(data: Data(#"TLD-format"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"John Klensin, RFC 1123 erratum 1353"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://www.rfc-editor.org/errata_search.php?eid=1353"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   Errata ID 1081, reported 2007-11-20, identifies a problem with the\012   evolution of naming of top-level domains and the text of RFC 1123.\012   It reads:\012\012   Section 2.1 says:\012\012                           However, a valid host name can never\012   have the dotted-decimal form \043.\043.\043.\043, since at least the\012   highest-level component label will be alphabetic.\012\012   It should say:\012\012                           However, a valid host name can never\012   have the dotted-decimal form \043.\043.\043.\043, since at least the\012   highest-level component label will be not all-numeric.\012\012   Notes:\012\012   RFC 3696 section 2 states: \042There is an additional rule that\012   essentially requires that top-level domain names not be\012   all-numeric.\042 The eleven IDN test TLDs created in\012   September 2007 contain hyphen-minus as specified in the\012   IDNA RFCs.\012   It should say:\012\012   However, a valid host name can never have the dotted-decimal\012   form \043.\043.\043.\043, since this change does not permit the highest-level\012   component label to start with a digit even if it is not all-numeric.\012   Notes:\012\012   This is a correct identification of the problem, but the wrong fix.\012   RFC 3696, which ID 1081 cites, is an informational document that is\012   deliberately relaxed about the fine details and says so. It is not\012   relevant to determination of the text that should have been (with\012   perfect knowledge of the future) in 1123.\012\012   Based on discussions when we were doing RFC 1591 and subsequently,\012   the expectation then (and presumably when 1123 was written) was\012   that the name of any new TLD would follow the rules for the\012   existing ones, i.e., that they would be exactly two or three\012   characters long and be all-alphabetic (which is exactly what 1123\012   says). The slightly-odd \042will be\042 language in 1123 was, I believe,\012   because that restriction was expected to be enforced by IANA,\012   rather than being a protocol issue. ICANN, with a different set of\012   assignment policies, effectively eliminated the length rule with\012   the TLDs allocated in 2000. IDNA (RFC 3490) uses a syntax for IDNs\012   that requires embedded hyphens in TLDs if there were ever to be an\012   actual IDN TLD (hence the comment in ID 1081 about the IANA IDN\012   testbed).\012\012   While the proposed correction in Errata ID 1081 would fix the\012   problem by imposing the narrowest possible restriction (\042not\012   all-numeric\042), the original host name rule and the original\012   statement in 1123 both assume the possibility of a minimal check\012   to differentiate between domain names and IP addresses, i.e.,\012   checking the first digit only. Because I believe that there are\012   probably implementations that depend on such minimal parsing --some\012   probably ancient and embedded-- it would appear to be wise to relax\012   the rule as little as possible and, in particular, to restrict the\012   \042leading digit\042 exception to domains below the top-level, as 1123\012   effectively does.\012\012   The suggested text above reflects that reasoning. Because of the\012   possible consequences of this issue, I would hope that it would be\012   discussed with the relevant DNS-related WGs, the Root Server Advisory\012   Committee (RSAC), and with IANA for comment and as a heads-up. This\012   issue is substantive enough that it should probably be dealt with by\012   a document that explicitly updates 1123 and that is processed on the\012   Standards Track, but an accurate statement in the errata is the\012   next-best option until that can be done. In the interim and while\012   this suggestion is being discussed, Errata ID 1081 should probably\012   be taken out of \042validated\042 status."#.utf8), encoding: .nonLossyASCII)!)
		public static let mailboxMaximum = ValidationReference(xmlId: String(data: Data(#"mailbox-maximum"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"Dominic Sayers, RFC 3696 erratum 1690"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://www.rfc-editor.org/errata_search.php?eid=1690"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   However, there is a restriction in RFC 2821 on the length of an\012   address in MAIL and RCPT commands of 254 characters.  Since addresses\012   that do not fit in those fields are not normally useful, the upper\012   limit on address lengths should normally be considered to be 254.\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let domainMaximum = ValidationReference(xmlId: String(data: Data(#"domain-maximum"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5321 section 4.5.3.1.2"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc1035\043section-4.5.3.1.2"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   The maximum total length of a domain name or number is 255 octets.\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let mailbox = ValidationReference(xmlId: String(data: Data(#"mailbox"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5321 section 4.1.2"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5321\043section-4.1.2"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   Mailbox        = Local-part \042@\042 ( Domain / address-literal )\012"#.utf8), encoding: .nonLossyASCII)!)
		public static let addrSpec = ValidationReference(xmlId: String(data: Data(#"addr-spec"#.utf8), encoding: .nonLossyASCII)!, blockQuoteName: String(data: Data(#"RFC 5322 section 3.4.1"#.utf8), encoding: .nonLossyASCII)!, blockQuoteURL: URL(string: String(data: Data(#"https://tools.ietf.org/html/rfc5322\043section-3.4.1"#.utf8), encoding: .nonLossyASCII)!)!, blockQuote: String(data: Data(#"\012   addr-spec       =   local-part \042@\042 domain\012"#.utf8), encoding: .nonLossyASCII)!)
		
		public let xmlId: String
		
		public let blockQuoteName: String
		public let blockQuoteURL: URL
		public let blockQuote: String

		private init(xmlId pi: String, blockQuoteName bqn: String, blockQuoteURL bqu: URL, blockQuote bq: String) {
			xmlId = pi
			blockQuoteName = bqn
			blockQuoteURL = bqu
			blockQuote = bq
		}
		
	}
	
}


extension Email {
	
	public struct ValidationDiagnosis : Hashable {
		
		public static let valid = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_VALID"#.utf8), encoding: .nonLossyASCII)!, value: 0, category: .validCategory, smtpInfo: .code250215, references: [], description: String(data: Data(#"Address is valid. Please note that this does not mean the address actually exists, nor even that the domain actually exists. This address could be issued by the domain owner without breaking the rules of any RFCs."#.utf8), encoding: .nonLossyASCII)!)
		public static let dnswarnNoMxRecord = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_DNSWARN_NO_MX_RECORD"#.utf8), encoding: .nonLossyASCII)!, value: 5, category: .dnswarn, smtpInfo: .code250215, references: [], description: String(data: Data(#"Couldn't find an MX record for this domain but an A-record does exist"#.utf8), encoding: .nonLossyASCII)!)
		public static let dnswarnNoRecord = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_DNSWARN_NO_RECORD"#.utf8), encoding: .nonLossyASCII)!, value: 6, category: .dnswarn, smtpInfo: .code250215, references: [], description: String(data: Data(#"Couldn't find an MX record or an A-record for this domain"#.utf8), encoding: .nonLossyASCII)!)
		public static let rfc5321Tld = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_RFC5321_TLD"#.utf8), encoding: .nonLossyASCII)!, value: 9, category: .rfc5321, smtpInfo: .code250215, references: [.tld], description: String(data: Data(#"Address is valid but at a Top Level Domain"#.utf8), encoding: .nonLossyASCII)!)
		public static let rfc5321Tldnumeric = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_RFC5321_TLDNUMERIC"#.utf8), encoding: .nonLossyASCII)!, value: 10, category: .rfc5321, smtpInfo: .code250215, references: [.tldFormat], description: String(data: Data(#"Address is valid but the Top Level Domain begins with a number"#.utf8), encoding: .nonLossyASCII)!)
		public static let rfc5321Quotedstring = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_RFC5321_QUOTEDSTRING"#.utf8), encoding: .nonLossyASCII)!, value: 11, category: .rfc5321, smtpInfo: .code250215, references: [.quotedString], description: String(data: Data(#"Address is valid but contains a quoted string"#.utf8), encoding: .nonLossyASCII)!)
		public static let rfc5321Addressliteral = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_RFC5321_ADDRESSLITERAL"#.utf8), encoding: .nonLossyASCII)!, value: 12, category: .rfc5321, smtpInfo: .code250215, references: [.addressLiteral, .addressLiteralIpv4], description: String(data: Data(#"Address is valid but at a literal address not a domain"#.utf8), encoding: .nonLossyASCII)!)
		public static let rfc5321Ipv6Deprecated = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_RFC5321_IPV6DEPRECATED"#.utf8), encoding: .nonLossyASCII)!, value: 13, category: .deprec, smtpInfo: .code250215, references: [.addressLiteralIpv6], description: String(data: Data(#"Address is valid but contains a :: that only elides one zero group. All implementations must accept and be able to handle any legitimate RFC 4291 format."#.utf8), encoding: .nonLossyASCII)!)
		public static let cfwsComment = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_CFWS_COMMENT"#.utf8), encoding: .nonLossyASCII)!, value: 17, category: .cfws, smtpInfo: .code250215, references: [.dotAtom], description: String(data: Data(#"Address contains comments"#.utf8), encoding: .nonLossyASCII)!)
		public static let cfwsFws = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_CFWS_FWS"#.utf8), encoding: .nonLossyASCII)!, value: 18, category: .cfws, smtpInfo: .code250215, references: [.localPart], description: String(data: Data(#"Address contains Folding White Space"#.utf8), encoding: .nonLossyASCII)!)
		public static let deprecLocalpart = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_DEPREC_LOCALPART"#.utf8), encoding: .nonLossyASCII)!, value: 33, category: .deprec, smtpInfo: .code553511, references: [.obsLocalPart], description: String(data: Data(#"The local part is in a deprecated form"#.utf8), encoding: .nonLossyASCII)!)
		public static let deprecFws = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_DEPREC_FWS"#.utf8), encoding: .nonLossyASCII)!, value: 34, category: .deprec, smtpInfo: .code553513, references: [.obsLocalPart, .obsDomain], description: String(data: Data(#"Address contains an obsolete form of Folding White Space"#.utf8), encoding: .nonLossyASCII)!)
		public static let deprecQtext = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_DEPREC_QTEXT"#.utf8), encoding: .nonLossyASCII)!, value: 35, category: .deprec, smtpInfo: .code553513, references: [.obsQtext], description: String(data: Data(#"A quoted string contains a deprecated character"#.utf8), encoding: .nonLossyASCII)!)
		public static let deprecQp = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_DEPREC_QP"#.utf8), encoding: .nonLossyASCII)!, value: 36, category: .deprec, smtpInfo: .code553513, references: [.obsQp], description: String(data: Data(#"A quoted pair contains a deprecated character"#.utf8), encoding: .nonLossyASCII)!)
		public static let deprecComment = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_DEPREC_COMMENT"#.utf8), encoding: .nonLossyASCII)!, value: 37, category: .deprec, smtpInfo: .code553513, references: [.obsLocalPart, .obsDomain], description: String(data: Data(#"Address contains a comment in a position that is deprecated"#.utf8), encoding: .nonLossyASCII)!)
		public static let deprecCtext = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_DEPREC_CTEXT"#.utf8), encoding: .nonLossyASCII)!, value: 38, category: .deprec, smtpInfo: .code553513, references: [.obsCtext], description: String(data: Data(#"A comment contains a deprecated character"#.utf8), encoding: .nonLossyASCII)!)
		public static let deprecCfwsNearAt = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_DEPREC_CFWS_NEAR_AT"#.utf8), encoding: .nonLossyASCII)!, value: 49, category: .deprec, smtpInfo: .code553513, references: [.cfwsNearAt, .shouldNot], description: String(data: Data(#"Address contains a comment or Folding White Space around the @ sign"#.utf8), encoding: .nonLossyASCII)!)
		public static let rfc5322Domain = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_RFC5322_DOMAIN"#.utf8), encoding: .nonLossyASCII)!, value: 65, category: .rfc5322, smtpInfo: .code553512, references: [.domainRfc5322], description: String(data: Data(#"Address is RFC 5322 compliant but contains domain characters that are not allowed by DNS"#.utf8), encoding: .nonLossyASCII)!)
		public static let rfc5322Toolong = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_RFC5322_TOOLONG"#.utf8), encoding: .nonLossyASCII)!, value: 66, category: .rfc5322, smtpInfo: .code553513, references: [.mailboxMaximum], description: String(data: Data(#"Address is too long"#.utf8), encoding: .nonLossyASCII)!)
		public static let rfc5322LocalToolong = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_RFC5322_LOCAL_TOOLONG"#.utf8), encoding: .nonLossyASCII)!, value: 67, category: .rfc5322, smtpInfo: .code553511, references: [.localPartMaximum], description: String(data: Data(#"The local part of the address is too long"#.utf8), encoding: .nonLossyASCII)!)
		public static let rfc5322DomainToolong = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_RFC5322_DOMAIN_TOOLONG"#.utf8), encoding: .nonLossyASCII)!, value: 68, category: .rfc5322, smtpInfo: .code553512, references: [.domainMaximum], description: String(data: Data(#"The domain part is too long"#.utf8), encoding: .nonLossyASCII)!)
		public static let rfc5322LabelToolong = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_RFC5322_LABEL_TOOLONG"#.utf8), encoding: .nonLossyASCII)!, value: 69, category: .rfc5322, smtpInfo: .code553512, references: [.label], description: String(data: Data(#"The domain part contains an element that is too long"#.utf8), encoding: .nonLossyASCII)!)
		public static let rfc5322Domainliteral = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_RFC5322_DOMAINLITERAL"#.utf8), encoding: .nonLossyASCII)!, value: 70, category: .rfc5322, smtpInfo: .code553513, references: [.domainLiteral], description: String(data: Data(#"The domain literal is not a valid RFC 5321 address literal"#.utf8), encoding: .nonLossyASCII)!)
		public static let rfc5322DomlitObsdtext = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_RFC5322_DOMLIT_OBSDTEXT"#.utf8), encoding: .nonLossyASCII)!, value: 71, category: .rfc5322, smtpInfo: .code553513, references: [.obsDtext], description: String(data: Data(#"The domain literal is not a valid RFC 5321 address literal and it contains obsolete characters"#.utf8), encoding: .nonLossyASCII)!)
		public static let rfc5322Ipv6Grpcount = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_RFC5322_IPV6_GRPCOUNT"#.utf8), encoding: .nonLossyASCII)!, value: 72, category: .rfc5322, smtpInfo: .code553513, references: [.addressLiteralIpv6], description: String(data: Data(#"The IPv6 literal address contains the wrong number of groups"#.utf8), encoding: .nonLossyASCII)!)
		public static let rfc5322Ipv62X2Xcolon = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_RFC5322_IPV6_2X2XCOLON"#.utf8), encoding: .nonLossyASCII)!, value: 73, category: .rfc5322, smtpInfo: .code553513, references: [.addressLiteralIpv6], description: String(data: Data(#"The IPv6 literal address contains too many :: sequences"#.utf8), encoding: .nonLossyASCII)!)
		public static let rfc5322Ipv6Badchar = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_RFC5322_IPV6_BADCHAR"#.utf8), encoding: .nonLossyASCII)!, value: 74, category: .rfc5322, smtpInfo: .code553513, references: [.addressLiteralIpv6], description: String(data: Data(#"The IPv6 address contains an illegal group of characters"#.utf8), encoding: .nonLossyASCII)!)
		public static let rfc5322Ipv6Maxgrps = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_RFC5322_IPV6_MAXGRPS"#.utf8), encoding: .nonLossyASCII)!, value: 75, category: .rfc5322, smtpInfo: .code553513, references: [.addressLiteralIpv6], description: String(data: Data(#"The IPv6 address has too many groups"#.utf8), encoding: .nonLossyASCII)!)
		public static let rfc5322Ipv6Colonstrt = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_RFC5322_IPV6_COLONSTRT"#.utf8), encoding: .nonLossyASCII)!, value: 76, category: .rfc5322, smtpInfo: .code553513, references: [.addressLiteralIpv6], description: String(data: Data(#"IPv6 address starts with a single colon"#.utf8), encoding: .nonLossyASCII)!)
		public static let rfc5322Ipv6Colonend = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_RFC5322_IPV6_COLONEND"#.utf8), encoding: .nonLossyASCII)!, value: 77, category: .rfc5322, smtpInfo: .code553513, references: [.addressLiteralIpv6], description: String(data: Data(#"IPv6 address ends with a single colon"#.utf8), encoding: .nonLossyASCII)!)
		public static let errExpectingDtext = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_ERR_EXPECTING_DTEXT"#.utf8), encoding: .nonLossyASCII)!, value: 129, category: .err, smtpInfo: .code553512, references: [.dtext], description: String(data: Data(#"A domain literal contains a character that is not allowed"#.utf8), encoding: .nonLossyASCII)!)
		public static let errNolocalpart = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_ERR_NOLOCALPART"#.utf8), encoding: .nonLossyASCII)!, value: 130, category: .err, smtpInfo: .code553511, references: [.localPart], description: String(data: Data(#"Address has no local part"#.utf8), encoding: .nonLossyASCII)!)
		public static let errNodomain = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_ERR_NODOMAIN"#.utf8), encoding: .nonLossyASCII)!, value: 131, category: .err, smtpInfo: .code553512, references: [.addrSpec, .mailbox], description: String(data: Data(#"Address has no domain part"#.utf8), encoding: .nonLossyASCII)!)
		public static let errConsecutivedots = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_ERR_CONSECUTIVEDOTS"#.utf8), encoding: .nonLossyASCII)!, value: 132, category: .err, smtpInfo: .code553511, references: [.localPart, .domainRfc5322, .domainRfc5321], description: String(data: Data(#"The address may not contain consecutive dots"#.utf8), encoding: .nonLossyASCII)!)
		public static let errAtextAfterCfws = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_ERR_ATEXT_AFTER_CFWS"#.utf8), encoding: .nonLossyASCII)!, value: 133, category: .err, smtpInfo: .code553513, references: [.localPart, .domainRfc5322], description: String(data: Data(#"Address contains text after a comment or Folding White Space"#.utf8), encoding: .nonLossyASCII)!)
		public static let errAtextAfterQs = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_ERR_ATEXT_AFTER_QS"#.utf8), encoding: .nonLossyASCII)!, value: 134, category: .err, smtpInfo: .code553511, references: [.localPart], description: String(data: Data(#"Address contains text after a quoted string"#.utf8), encoding: .nonLossyASCII)!)
		public static let errAtextAfterDomlit = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_ERR_ATEXT_AFTER_DOMLIT"#.utf8), encoding: .nonLossyASCII)!, value: 135, category: .err, smtpInfo: .code553512, references: [.domainRfc5322], description: String(data: Data(#"Extra characters were found after the end of the domain literal"#.utf8), encoding: .nonLossyASCII)!)
		public static let errExpectingQpair = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_ERR_EXPECTING_QPAIR"#.utf8), encoding: .nonLossyASCII)!, value: 136, category: .err, smtpInfo: .code553511, references: [.quotedPair], description: String(data: Data(#"The address contains a character that is not allowed in a quoted pair"#.utf8), encoding: .nonLossyASCII)!)
		public static let errExpectingAtext = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_ERR_EXPECTING_ATEXT"#.utf8), encoding: .nonLossyASCII)!, value: 137, category: .err, smtpInfo: .code553511, references: [.atext], description: String(data: Data(#"Address contains a character that is not allowed"#.utf8), encoding: .nonLossyASCII)!)
		public static let errExpectingQtext = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_ERR_EXPECTING_QTEXT"#.utf8), encoding: .nonLossyASCII)!, value: 138, category: .err, smtpInfo: .code553511, references: [.qtext], description: String(data: Data(#"A quoted string contains a character that is not allowed"#.utf8), encoding: .nonLossyASCII)!)
		public static let errExpectingCtext = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_ERR_EXPECTING_CTEXT"#.utf8), encoding: .nonLossyASCII)!, value: 139, category: .err, smtpInfo: .code553511, references: [.qtext], description: String(data: Data(#"A comment contains a character that is not allowed"#.utf8), encoding: .nonLossyASCII)!)
		public static let errBackslashend = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_ERR_BACKSLASHEND"#.utf8), encoding: .nonLossyASCII)!, value: 140, category: .err, smtpInfo: .code553512, references: [.domainRfc5322, .domainRfc5321, .quotedPair], description: String(data: Data(#"The address can't end with a backslash"#.utf8), encoding: .nonLossyASCII)!)
		public static let errDotStart = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_ERR_DOT_START"#.utf8), encoding: .nonLossyASCII)!, value: 141, category: .err, smtpInfo: .code553511, references: [.localPart, .domainRfc5322, .domainRfc5321], description: String(data: Data(#"Neither part of the address may begin with a dot"#.utf8), encoding: .nonLossyASCII)!)
		public static let errDotEnd = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_ERR_DOT_END"#.utf8), encoding: .nonLossyASCII)!, value: 142, category: .err, smtpInfo: .code553511, references: [.localPart, .domainRfc5322, .domainRfc5321], description: String(data: Data(#"Neither part of the address may end with a dot"#.utf8), encoding: .nonLossyASCII)!)
		public static let errDomainhyphenstart = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_ERR_DOMAINHYPHENSTART"#.utf8), encoding: .nonLossyASCII)!, value: 143, category: .err, smtpInfo: .code553512, references: [.subDomain], description: String(data: Data(#"A domain or subdomain cannot begin with a hyphen"#.utf8), encoding: .nonLossyASCII)!)
		public static let errDomainhyphenend = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_ERR_DOMAINHYPHENEND"#.utf8), encoding: .nonLossyASCII)!, value: 144, category: .err, smtpInfo: .code553512, references: [.subDomain], description: String(data: Data(#"A domain or subdomain cannot end with a hyphen"#.utf8), encoding: .nonLossyASCII)!)
		public static let errUnclosedquotedstr = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_ERR_UNCLOSEDQUOTEDSTR"#.utf8), encoding: .nonLossyASCII)!, value: 145, category: .err, smtpInfo: .code553512, references: [.quotedString], description: String(data: Data(#"Unclosed quoted string"#.utf8), encoding: .nonLossyASCII)!)
		public static let errUnclosedcomment = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_ERR_UNCLOSEDCOMMENT"#.utf8), encoding: .nonLossyASCII)!, value: 146, category: .err, smtpInfo: .code553512, references: [.cfws], description: String(data: Data(#"Unclosed comment"#.utf8), encoding: .nonLossyASCII)!)
		public static let errUncloseddomlit = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_ERR_UNCLOSEDDOMLIT"#.utf8), encoding: .nonLossyASCII)!, value: 147, category: .err, smtpInfo: .code553512, references: [.domainLiteral], description: String(data: Data(#"Domain literal is missing its closing bracket"#.utf8), encoding: .nonLossyASCII)!)
		public static let errFwsCrlfX2 = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_ERR_FWS_CRLF_X2"#.utf8), encoding: .nonLossyASCII)!, value: 148, category: .err, smtpInfo: .code553513, references: [.cfws], description: String(data: Data(#"Folding White Space contains consecutive CRLF sequences"#.utf8), encoding: .nonLossyASCII)!)
		public static let errFwsCrlfEnd = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_ERR_FWS_CRLF_END"#.utf8), encoding: .nonLossyASCII)!, value: 149, category: .err, smtpInfo: .code553513, references: [.cfws], description: String(data: Data(#"Folding White Space ends with a CRLF sequence"#.utf8), encoding: .nonLossyASCII)!)
		public static let errCrNoLf = ValidationDiagnosis(xmlId: String(data: Data(#"ISEMAIL_ERR_CR_NO_LF"#.utf8), encoding: .nonLossyASCII)!, value: 150, category: .err, smtpInfo: .code553513, references: [.cfws, .crlf], description: String(data: Data(#"Address contains a carriage return that is not followed by a line feed"#.utf8), encoding: .nonLossyASCII)!)
		
		public let xmlId: String
		
		public let value: Int
		public let category: ValidationCategory
		public let smtpInfo: ValidationSMTPInfo
		public let references: [ValidationReference]
		public let description: String
		
		private init(xmlId pi: String, value v: Int, category c: ValidationCategory, smtpInfo si: ValidationSMTPInfo, references r: [ValidationReference], description d: String) {
			xmlId = pi
			value = v
			category = c
			smtpInfo = si
			references = r
			description = d
		}
		
	}
	
}
